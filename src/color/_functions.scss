@use 'sass:color';
@use 'sass:map';
@use 'sass:math';
@use 'sass:string';

@use '../math' as mth;

/// CREATE SHADES
/// ----------
/// A color function that generates a map for a given color, using the initial value as a base and
/// adjusting the lightness to create values from `0` - `1000` in increments of 100.
/// The original colour will be included twice in the map. Once according to it's lightness, and once
/// under the key of `base`, for ease of reference.
///
/// @param $clr {Color} any color value that will be used to calculate the rest of the map.
/// @return {Map} an map of color values assigned to numbers 0, 100, 200...900, 1000.
///
@function create-shades($clr) {
  // initialise map with a single key, meaning the original colour can always be accessed at `base`.
  $shades: (base: $clr);
  // get initial values of the color's lightness and, from that, its "index".
  // I.e., a color with lightness `60%` would create an `$init: 6`.
  $lightness: color.lightness($clr);
  $init: math.floor(math.div($lightness, 10%));

  @for $i from 0 through 10 {
    $key: $i * 100;
    $value: color.scale($clr, $lightness: -10% * ($init - $i));
    $shades: map.set($shades, $key, $value);
  }

  @return $shades;
}

@function rgb-to-hex($val) {
  $channels: (
    red: color.red($val),
    green: color.green($val),
    blue: color.blue($val),
  );

  $output: ();
  @each $channel, $value in $channels {
    @if $value > 0 {
      $hexValue: mth.to-radix($value, 16);
      @if $value < 16 { $hexValue: "0#{$hexValue}"; }
      $output: map.set($output, $channel, $hexValue);
    } @else {
      $output: map.set($output, $channel, '00');
    }
  }

  @return #{'#'}#{map.get($output, red)}#{map.get($output, green)}#{map.get($output, blue)};
}